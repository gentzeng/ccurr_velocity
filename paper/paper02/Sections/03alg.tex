\section{Measuring money in circulation}
\label{sec:measure}%

In \cite{pernice2019cryptocurrencies} monetary units are seen as ``in circulation'' for measurement day \(\perd\)
if they have been used as a medium of exchange. %
Money is referred to as circulating if it has been moved economically within the last day, month, year or generally any time period $\wndw_\perd$%
The measure is set up in a way that measurement-day \(\perd\) constitutes the last day of window \(\wndw_\perd\) for which money in circulation is to be estimated (compare figure~\ref{fig:timevars}). %
Monetary units brought into circulation in the last second of day \(\perd\) are to be attributed to belong to money in circulation for \(\perd\). %  

\begin{figure*}[ht!]%
	\centering
	\ifdefined\varInputFigs%
%	\includegraphics[width=0.8\linewidth]{fig/mcirc_concept_window_uneqal_period_HR}%
	\input{ts_figs/mcirc_concept}
	\else%
	\fi%
	\caption{%
		An example of a transaction chain. %
	}%
	\label{fig:mcirc_concept}%
\end{figure*}%

% \input{Alg/alg01.tex}% We don't need that anymore. Just keep it to look it up some time.
\input{Alg/alg04.tex}%GetMCirc
\input{Alg/alg03.tex}%AdjustMCirc
\input{Alg/alg05.tex}%Aggregation

\subsection{Intuition and original approach}
\label{sec:orig_approach}%
To estimate the subset of money supply which circulated within $\wndw$, the authors suggested to analyze the transactions recorded window $\wndw$.  %
Ignoring change, outputs of coinbase transactions and as well as transactions spending outputs generated before $\wndw$ are interpreted as bringing an amount into circulation that corresponds to the value of spent outputs.  %
All inputs referring to UTXOs generated \emph{within} period $\wndw$, on the
other hand, re-spend money which has already been counted as circulating.%
%
\textbf{[@TODO Check against illustration.]}
This can be illustrated with \reffig{mcirc_concept} where values are symbolized with coins. %
Here, we would need to determine, how many monetary units have made the transaction volume $8$ (sum of outputs in C, D, E and F excluding self-churn) during period $\wndw$ possible. %
In this example, we would need to focus on transactions A, B and D in contrast to transactions C and E which reused monetary unspent transaction outputs that have been generated within period $\wndw$. %

If change in transactions is to be considered, the general approach is complicated by a technicality of UTXO-based cryptocurrencies: Transactions always spend prior transaction outputs in full. %

The authors defined two general approaches: \ac{wba} and \ac{mca}.  %
\ac{wba} considers the sum of all inputs \textit{in circulation} (as technically all has been proven to be available for transactions) while the \ac{mca} only counts the fraction economically sent to third parties.  %
%
They are visualized in \reffig{mcirc_concept}.  %
The moved-coin approach considers only output $\mathsf{Out_1}$ of transaction $\mathsf{Tx_C}$ as circulating, not the change output.  %
This approach captures the net economic value transferred to a third party.  %
The \ac{wba} classifies the whole input of transaction $\mathsf{Tx_C}$ as circulating.  %

However, as for UTXO blockchains the relation between transaction inputs and outputs are not determined, \ac{mca} might not be defined clearly. %
If for a given transaction one input was generated within and one before $\wndw$, it remains unspecified which one corresponds to the change output.  %

The authors thus utilized assignment rule between transaction inputs and outputs utilizing the terminology of cost accounting: %
They differentiate between \ac{fifo}, where youngest inputs get assigned to outputs first, and \ac{lifo}, where it is the other way around.  %

The authors introduced three definitions of money in circulation as measured for day \(\perd\), each defined by their respective windows \(\wndw\): %
Money in circulation for period $\wndw$ adopting the \ac{wba} ($ \MCircWbPWl $), and both the \ac{mca} with the \ac{lifo} rule ($ \MCircMlPWl $) and the \ac{fifo} rule ($ \MCircMfPWl $).

\subsection{Necessity for a more efficient implementation}
\label{sec:necessity_effi}%
Applying their measure to Bitcoin data, \cite{pernice2019cryptocurrencies} where analyzing data for a velocity estimate based on money which has been circulating within the last day. %
Basing money in circulation on a monthly or yearly basis might provide interesting insights and was suggested by the authors as potential avenue for future research. %
The implementation suggested, however, is rather inefficient for larger time windows \(\wndw\). %

The algorithm proposed in \cite{pernice2019cryptocurrencies} loops over-and-over again over the same transactions as windows \(\wndw\) overlap: %
As illustrated in the conceptional description of the three velocity measures, determining whether an unspent output was spent in a given time window is essential for the chosen approach. %
While this is computationally feasible for small time windows, already for look-back windows of a few days, naively looping through all transactions is problematic. %
For daily timeseries data and multiday look-back time windows the data for computations overlaps. %
The published code on \url{https://github.com/wiberlin/ccurr_velocity} for a look-back time window of a week takes XYZ hours to terminate even if restricted on the first 3 years of the Bitcoin blockchain and run using all XY cores of a server with XY GB ram. 
\textbf{[TODO George: Here comes some O-Notation magic!]}
We thus propose an improved algorithmic implementation proceeding inductively. %

\subsection{Inaccuracy due to mistreatment of transaction fees}
\label{sec:inaccuracy_fees}%
Relying only on non-recycling transaction outputs and coinbase transactions to estimate money in circulation, the approach chosen by \cite{pernice2019cryptocurrencies} misrepresents fees as always in circulation. %
The reasons is that fees are captured by outputs of coinbase transactions which, when spent, are always added to the circulating money supply . %
This is a slight misrepresentation. %
Fees of transactions that have been respent in within time window \(\wndw\) ought to be considered respent as well. %
We thus, in addition to addressing the issue summarized in section \ref{sec:necessity_effi}, suggest a slight adaptation improving the estimates precision. %

\subsection{Disentanglement of  transaction fees}
\label{sec:improve_fees}%
\begin{figure}[t]
	\input{ts_figs/coinbase}
	\centering
	\caption{Overview of preprocessing of coinbase transactions. Although coinbase transactions have no inputs, we regard fees collected in a coinbase transactions's block as pseudo-inputs.}
\end{figure}



\subsection{Efficiency improvements}
\label{sec:novel_impl}%

\subsubsection{Intuition}
\label{sec:novel_impl_intuition}%
Our approach allows for reusing and adjusting information of calculations for prior time-windows instead of recalculating them entirely for every day. %
While the novel implementation allows effectively for larger time-windows \(\wndwLength\), we reuse the general approach for measuring money in circulation proposed in \cite{pernice2019cryptocurrencies}. %
We do adapt it, however, by adjusting and recombining its elements. %
Our implementation steps through time by iteration periods \(\iterp\) which we chose to be 1 day each. %
A single inductive step \(\iteri\) takes the amount of money in circulation for time window \(\wndw_\iteri\) and reuses most of its information to calculate an estimate for \(\wndw_{iteri+1}\). %
Simply put, for every iteration step we thus add a new day to \(\wndw_{\iteri}\) (lets call him \(\iterhead\)) and eliminate the oldest one (lets call him \(\itertail\)). %
As a consequence we have to adjust the estimate for window \(\wndw_\iteri\) for the transactions in the above two days. %
Roughly spoken, we thus:
\begin{enumerate}
\item add the value of monetary units put into circulation by the transactions of the day that was just added, %
\item and subtract monetary units that had belonged to the day that was just eliminated %
\end{enumerate}
from window \(\wndw_{\iteri}\) to form the new window \(\wndw_{\iteri+1}\). %
How do the two steps proceed exactly and why is that the same as looping over all transactions in period \(\wndw\) for which money in circulation is to be estimated?
Figure \ref{fig:aggr} illustrates the intuition. % 
While step 1 simply estimating, aggregating and lastly add money put to circulation for each transaction pursued in day \(d\) following the scheme in Section \ref{sec:orig_approach}, step 2 is slightly more complex. %
Simply subtracting aggregating money put into circulation by transactions during the eliminated day \(d_{sub}\) is inaccurate. %
While the respective transactions are to be eliminated from the information set of the new window \(\wndw_{\iteri+1}\), transactions within the window might be linked to outputs from transactions having occurred during the eliminated day. %
Thus those transactions, now linking to outputs generated before the shifted starting date of \(\wndw_{\iteri+1}\) are not respending outputs anymore but now are to be counted as putting money into circulation. %
\textbf{TODO: Link better to illustration when fig finished.}


Why are we relying on induction instead of simply pre-calculating estimates for each day separately and then aggregating them? %
\textbf{TODO: Add in what broke initial idea.}


\subsubsection{Algorithmic implementation}
\label{sec:novel_impl_algo}%
\textbf{[TODO: Here the variables are still not in line with the rest of the paper and window length, index and period confusing.]}

The sketched implementation of the inductive framework is given in Algorithm \ref{algo:code_aggr}. %
The framework takes window \(\wndw\) and pre-cashed a data structure offering the set of coinbase outputs representing fees per block-height as input. %
It then loops trough every iteration period \(d\) constituting the whole history of the blockchain. %
In a first preparative step, pre-computes helper-structures for each day \(d\):
\begin{itemize}
\item \( \MSetCirc_{1}[d] \), money drawn into active circulation by the transactions of day \( d \) if a window of 1 is assumed,
\item \( \MSetCircLB[d] \), money drawn into active circulation by the transactions of day \(d\) if a window of w is assumed,
\item \( \MSetCircLA[d] \), and a corrective value based on transaction outputs from transactions during day \(d\) that can no longer be seen as ``respent-coins'' for window \(\wndw\).  
\end{itemize}

For now, we will simply treat the above three structures as black boxes and focus on the iterative framework which starts at line 17 of the pseudo-code.%
\footnote{The calculations for the three helper-structure are summarized in the following paragraphs.} %

The regular inductive steps are taken for \(d \geq w \).%
\footnote{
For days \(d < \wndw \), money put into circulation for a window \(\wndw\) by transactions of day \(d\) is simply the output-sum of coinbase transactions \(\MSetCbs[d]\). %
We use this intuition to initialize the algorithm.} %
First of all, as described in Section \ref{sec:novel_impl_intuition}, we set \(\MSetCircAggr[d]\), money in circulation over time window \(w\) as measured for iteration day \(d\), simple to its last calculated value. %
This value is now the base for adjustments. %
Using the pre-computed values, we can simply following the intuition layed out in \ref{sec:novel_impl_intuition}: %
We add \(\MSetCircLB[d]\), and thus money brought into circulation on day \(d\) added to the previous window to \(\MSetCircAggr[d]\). %
After that, we then subtract money in circulation for the day eliminated from the \(\wndw - 1\) and thus \(\MSetCirc_{1}[d_{sub}]\). %
Without further adjustment, however, we would ignore that by shifting the window boundaries certain transaction outputs cannot be seen any longer as ``respent-coins'' as the spent output no longer lies ``inside'' the respectiv time window. %
We thus add \( \MSetCircLA[d_{sub}] \) which, roughly spoken, aggregates money brought into circulation by transactions sspending outputs of transactions during day \(d\) if the new window boundaries are applied. %

Why does this work?

\textbf{TODO: Plot with explanation}

How are \(\MSetCirc_{1}\), \( \MSetCircLA[d] \) and \( \MSetCircLB[d] \) calculated in detail? % 

As in the original implementation, the core of the estimation procedure is given by the decision rules determining the amount of money that is put into circulation by individual transactions (compare Algorithm \ref{algo:code_mcirc}).%
\footnote{Stressing the novel inductive implementation setup, we reduce the complexity of the calculations by illustrating only the calculations for the \ac{wba}. %
Note, that the pseudo-code for money in circulation under the assumptions of \ac{lifo} and \ac{fifo} can be checked out in our open-source repository \url{https://github.com/wiberlin/ccurr_velocity}.
}
If the respective amount can be estimated by looping trough all inputs \(\Inp_{t}\) of transaction \(t\) and adding up values of inputs \(\val(i)\) referencing to outputs of coinbase transactions or are generated before the first timestamp of time window \(\wndw\) which is characterizing the estimate to be achieved (compare Section \ref{sec:orig_approach}). %
This core-functionality is referenced as function throughout the paper as function \(GetMCirc\bigl(t,\,\typett,\,\wndw,\bigr)\). %

Let's first turn to the computation of \(\MSetCircLA[d]\) and \(\MSetCirc_{1}[d]\) respectively. %
Obviously, our implementation will just apply \(GetMCirc\bigl(t,\,\typett,\,\wndw,\bigr)\) to aggregate the money supply put into circulation by all transactions \(\TxD\) of day \(d\) that has been added when shifting the window in the inductive process. % 

The computation of adjustment value \(\MSetCircLB[d]\) is slightly more complex. %
As given in line 14 of Algorithm \ref{algo:code_aggr}, we apply a function \(\MCircAdj(t,w)\) to all transactions in day \(d\). %
The inner workings of \(\MCircAdj(t,w)\) are illustrated in Algorithm \ref{algo:code_outs_spent_within}: % 
For every transaction \(t\), \(\MCircAdj(t,w)\) loops through all outputs and establishes whether the respective output has served as input of a transaction within window \(\wndw\). %
For the output's ``spending-transacting'' we thus want to aggregate the values of outputs that represent money put into circulation with respect to the new window \(\wndw + 1\). %
In Algorithm \ref{algo:code_outs_spent_within}, this is illustrated by adding value of output 


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%% If confusion arises between "days forming iteration steps" and "days of measurement" 
% Assume that money in circulation with a look-back time window of length \(\wndwLength\) is to be estimated for day \(\perd\). %
% The helper-structure estimates how much money is been brought into active circulation during the period \([\iterp_{\Start},\iterp_{\End}]\): Before the events at day \(\iterp\), the respective money supply has remained untouched for \(\wndwLength\) days. With its transaction at day \(\iterp\), however, it can now be seen as circulating within period  \([\wndw_\Start\) to \(\wndw_\End]\). %
% While the helper-structure is estimating the value of monetary units which are ``activated'' by transactions of day \( \iterp \), it does neglect outputs which turn into ``already spent'' outputs in prior days within window \(\wndw\). %
% For example, in figure \ref{fig:mcirc_concept}, if we estimated the money supply for the period of iteration step \(\iterp\) we would count only money in circulation of 3 missing that transaction TX-C ``outside'' of period \(i\) activated a money supply of 2 with INP-1. %
% As a consequence it only coincides with the original estimator for the special case of \(\iterp % \wndw\). %

% While the original estimator requires the information of each transaction in time-window \(\wndw\), the helper-construct looks only at the transactions of iteration-step \(\iterp\) and checks their inputs age against \(\wndw_\Start\). % 

% The above helper-construct can be seen as the centerpiece to realize the inductive framework. %
% Algorithm \ref{algo:code_mcirc} offers a detailed summary. %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{figure}[ht!]%
% 	\centering
% 	\ifdefined\varInputFigs%
% 	\input{ts_figs/aggr}
% 	\else%
% 	\fi%
% 	\caption{%
% 		Overview of inductive computation of $\MCirc$. %
% 	}%
% 	\label{fig:aggr}%
% \end{figure}%

\begin{center}
%    \ifdefined\varInputFigs%
    \includegraphics[width=1\linewidth]{fig/iterations_general}%
%    \else%
%    \fi%
  \captionof{figure}{General iteration procedure.}
  \label{fig:aggr}
\end{center}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main.tex"
%%% End:

