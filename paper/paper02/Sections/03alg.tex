\section{Measuring money in circulation}
\label{sec:measure}%

In \cite{pernice2019cryptocurrencies} %
% monetary units are seen as ``in circulation'' for measurement day \(\perd\) if they have been used as medium of exchange. %
money is referred to as ``circulating'' if it has been moved economically within the last day, month, year or generally any time period $\wndw$.%
The measure is set up in a way that measurement-day \(\perd\) constitutes the last day of window \(\wndw\) for which money in circulation is to be estimated. %
%The length of time window is denominated \(\wndwLength\).
Monetary units brought into circulation in the last second of day \(\perd\) are to be attributed to belong to money in circulation for \(\perd\). %  

\begin{figure*}[ht!]%
	\centering
	\ifdefined\varInputFigs%
%	\includegraphics[width=0.8\linewidth]{fig/mcirc_concept_window_uneqal_period_HR}%
	\input{ts_figs/mcirc_concept}
	\else%
	\fi%
	\caption{%
		An example of a transaction chain. %
	}%
	\label{fig:mcirc_concept}%
\end{figure*}%

\input{Alg/alg01.tex}% We don't need that anymore. Just keep it to look it up some time.
\input{Alg/alg02.tex}% We don't need that anymore. Just keep it to look it up some time.
\input{Alg/alg04.tex}%GetMCirc
\input{Alg/alg03.tex}%AdjustMCirc
\input{Alg/alg05.tex}%Aggregation

\subsection{Intuition and original approach}
\label{sec:orig_approach}%
To estimate the subset of money supply which can be referred to as circulating, the authors suggested to analyze the transactions having occurred within $\wndw$. %
Generally, outputs spent \emph{within} but generated \emph{before} \(\wndw\) are interpreted as putting money into circulation. %
The same holds for freshly mined coins - the outputs of coinbase transactions. % 
The amount of money put into circulation within \(\wndw\) corresponds to the aggregated value of such outputs. %
On the other hand, transactions using the outputs of transactions having occurred in period $\wndw$ as well, are interpreted simply as re-spending money which has already been counted as circulating.%
%
This can be illustrated with \reffig{mcirc_concept} where values are symbolized with coins. %
Here, we would need to determine, how many monetary units have made the transaction volume of $8$ (sum of outputs in C, D, E and F excluding self-churn) during period $\wndw$ possible. %
In this example, we would need to focus on transactions A, B and D in contrast to transactions C and E which reused monetary unspent transaction outputs that have been generated within period $\wndw$. %

If change in transactions is to be considered, the general approach is complicated by a technicality of UTXO-based cryptocurrencies: Transactions always spend prior transaction outputs in full. %
The authors defined two general approaches: \ac{wba} and \ac{mca}.  %
\ac{wba} considers the sum of all inputs \textit{in circulation} (as technically all has been proven to be available for transactions) while the \ac{mca} only counts the fraction economically sent to third parties.  %
%
This is visualized in \reffig{mcirc_concept}.  %
The moved-coin approach considers only output $\mathsf{Out_1}$ of transaction $\mathsf{Tx_C}$ as circulating, not the change output.  %
This approach captures the net economic value transferred to a third party.  %
The \ac{wba} classifies the whole input of transaction $\mathsf{Tx_C}$ as circulating.  %

However, as for UTXO-based blockchains the relation between transaction inputs and outputs is undetermined, \ac{mca} might not be defined clearly. %
If for a given transaction one input was generated within and one before $\wndw$, it remains unspecified which one corresponds to the change output.  %
The authors thus utilized assignment rule between transaction inputs and outputs utilizing the terminology of cost accounting: %
They differentiate between \ac{fifo}, where youngest inputs get assigned to outputs first, and \ac{lifo}, where it is the other way around.  %

Summarizing, the authors introduced three definitions of money in circulation as measured for day \(\perd\), each defined by their respective window \(\wndw\): %
Money in circulation for period $\wndw$ adopting the \ac{wba} ($ \MCircWbW $), and both the \ac{mca} with the \ac{lifo} rule ($ \MCircMlW $) and the \ac{fifo} rule ($ \MCircMfW $).

\subsection{Necessity for a more efficient implementation}
\label{sec:necessity_effi}%
Applying their measure to Bitcoin data, in \cite{pernice2019cryptocurrencies} data for a velocity estimate based on money which has been circulating within the last day has been analyzed. %
Basing money in circulation on a monthly or yearly basis might provide interesting insights and was suggested by the authors as potential avenue for future research. %
The implementation suggested, however, is rather inefficient for larger time windows \(\wndw\). %
The algorithm proposed in \cite{pernice2019cryptocurrencies} loops over-and-over again over the same transactions as windows \(\wndw\) overlap. %
% As illustrated in the conceptional description of the three velocity measures, determining whether an unspent output was spent in a given time window is essential for the chosen approach. %
While this is computationally feasible for small time windows, already for overlapping windows of a few days, naively looping through all transactions has proven problematic. %
The published code on \url{https://github.com/wiberlin/ccurr_velocity} for a look-back time window of a week takes XYZ hours to terminate even if restricted on the first 3 years of the Bitcoin blockchain and run using all XY cores of a server with XY GB ram. 
\textbf{[TODO George: Here comes some O-Notation magic!]}
We thus propose an improved algorithmic implementation proceeding inductively. %

\subsection{Inaccuracy due to mistreatment of transaction fees}
\label{sec:inaccuracy_fees}%
Relying only on non-recycling transaction outputs and coinbase transactions to estimate money in circulation, the approach chosen by \cite{pernice2019cryptocurrencies} misrepresents fees. %
All fees are treated as money in circulation. %
The reasons is that fees are captured by outputs of coinbase transactions which, when spent, are always added to the circulating money supply. %
This is a slight misrepresentation. %
Fees of transactions that have been respent within time window \(\wndw\) ought to be considered ``respent coins'' as well. %
We thus, in addition to addressing the issue summarized in section \ref{sec:necessity_effi}, suggest a slight adaptation improving the estimates precision. %

\subsection{Disentanglement of  transaction fees}
\label{sec:improve_fees}%
\begin{figure}[t]
	\input{ts_figs/coinbase}
	\centering
	\caption{Overview of preprocessing of coinbase transactions. Although coinbase transactions have no inputs, we regard fees collected in a coinbase transactions's block as pseudo-inputs.}
\end{figure}



\subsection{Efficiency improvements}
\label{sec:novel_impl}%

\subsubsection{Intuition}
\label{sec:novel_impl_intuition}%
Our approach allows for reusing calculations. %
While the novel implementation allows effectively for larger time-windows \(\wndwLength\), we reuse the general approach for measuring money in circulation proposed in \cite{pernice2019cryptocurrencies}. %
We do adapt it, however, by adjusting and recombining its elements. %
Our implementation steps through time by iteration periods which we chose to be 1 day each. %
A single inductive step \(\iteri\) takes the amount of money in circulation for time window \(\wndw_\iteri\) and reuses it to calculate the estimate for \(\wndw_{\iteri+1}\) (compare Figure \ref{fig:aggr}). %
Simply put, for every iteration step we thus add a new day to the window of the last day \(\wndw_{\iteri-1}\) (lets call this day \(\iterhead_{\iteri}\)) and eliminate the oldest one (lets call him \(\itertail_{\iteri}\)). %
As a consequence we have to adjust the estimate for window \(\wndw_\iteri\) for the transactions in the above two days. %
Roughly spoken, we thus:
\begin{enumerate}
\item add the value of monetary units put into circulation by the transactions of the day \(\iterhead_{\iteri}\), %
\item subtract monetary units that had belonged to the day \(\itertail_{\iteri}\)), %
\item adjust for transactions that cannot be counted as ``respending coins'' any longer due to the shift from \(\wndw_{\iteri}\) to \(\wndw_{\iteri + 1}\). %
\end{enumerate}
How do the three steps proceed exactly and why is that the same as looping over all transactions in period \(\wndw\) for which \(\MCirc\) is to be estimated? %
Figure \ref{fig:aggr} illustrates the basic intuition. %
If money in circulation for window \(\wndw_{\iteri}\) is to be estimated, we use the previous estimate for window \(\wndw_{\iteri-1}\) as basis. %
Step 1, then, is simply estimating, aggregating and lastly adding money put to circulation for each transaction pursued in day \(\iterhead_{\iteri}\) following the basic ideas from Section \ref{sec:orig_approach}. %
In Figure \ref{fig:aggr}, for example, transaction chain \(\mathsf{A}\) features a single transaction during day \(\iterhead_{\iteri}\) which uses an input generated long ago. The respective transaction output would thus be added to \(\MCirc\).
Step 2 subtracts money supply that stems from transactions of the eliminated day \(\itertail_{\iteri}\). %
In Figure \ref{fig:aggr}, transaction chain \(\mathsf{B}\) has a single transaction which occurred during within the window in the previous iteration step, but now drops out with the elimination of \(\iterhead_{\iteri}\). %
The respective outputs do not represent coins put into circulation for period \(\wndw_{iteri}\) any more and thus need to be subtracted. %
Step 3 adjusts for transactions occurring on days within window \(\wndw_\iteri\) which might be linked to outputs from transactions having occurred during the eliminated day. %
These transactions cannot be seen as re-spending coins anymore but now are to be counted as putting money into circulation. %
This can be exemplified by \(\mathsf{C}\) in Figure \ref{fig:aggr}. %
The second transaction for calculating \(\MCirc\) for \(\wndw_{\iteri-1}\) would be counted as re-spending money put into circulation by the first transaction. %
With shifting \(\wndw_{\iteri-1}\) to \(\wndw_{\iteri}\) its the second transaction, however, that puts unspent transaction outputs from outside the window into circulation. %
Having subtracted money put into circulation by the first transaction of \(\mathsf{C}\) in step 2, we need to adjust our estimation of \(\MCirc\) by adding the value of the outputs used by the second transaction of \(\mathsf{C}\). %

% Why are we relying on induction instead of simply pre-calculating estimates for each day separately and then aggregating them? %
% \textbf{TODO: Add in what broke initial idea.}


\subsubsection{Algorithmic implementation}
\label{sec:novel_impl_algo}%
The exact implementation of the inductive framework sketched in Section \ref{sec:novel_impl_intuition} is given in Algorithm \ref{algo:code_aggr}. %
We step trough the transaction history day-by-day, shifting the window \(\wndw_{\iteri}\) with every iteration step \(\iteri\) to achieve estimates for measurement day \(\perd_{\iteri}\). %
To facilitate notation, we refer to windows and iteration periods dropping the index \(\iteri\) in Algorithms \ref{algo:code_mcirc_cond}, \ref{algo:code_mcirc} and \ref{algo:code_mcirc_for}. %

In a first preparative step, we pre-compute three helper-structures for each day \(\perd\), corresponding to the three implementation-steps presented in Section \ref{sec:novel_impl_intuition}:
\begin{enumerate}
\item \( \MSetCircLB[\perd] \), money drawn into active circulation by the transactions of day \(\perd\) if a window of w is assumed,
\item \( \MSetCirc_{1}[\perd] \), money drawn into active circulation by the transactions of day \( \perd \) if a window of 1 is assumed,
\item \( \MSetCircLA[\perd] \), and a corrective value based on transaction outputs from transactions during day \(\perd\) that can no longer be seen as ``respent-coins'' for window \(\wndw\).  
\end{enumerate}
For inductively calculating money in circulation for measurement period \(\perd\), the helper structures might be applied in shiftend fashion. %
If compared to Figure \ref{fig:aggr}, \( \MSetCircLB \) will be applied to a period inductivly added to the window \(\iterhead\). %
\( \MSetCirc_{1}\), however, is used for subtracting money supply from the elimination period \(\itertail\). %
Lastly, \( \MSetCircLA \) looks at transactions in the elimiated \(\itertail\) and checks, whether those have been used within the part of the new-formed window \(\wndw\) that lies in between \(\iterhead\) and \(\iterhead\). %


How are \(\MSetCirc_{1}\), \( \MSetCircLA[d] \) and \( \MSetCircLB[d] \) calculated in detail? %
As in the original implementation, the core of the estimation procedure is given by the decision rules determining the amount of money that is put into circulation by individual transactions. %
The procedure is summarized in Algorithm \ref{algo:code_mcirc}.%
\footnote{Stressing the novel inductive implementation setup, we reduce the complexity of the calculations by illustrating only the calculations for the \ac{wba}. %
Note, that the pseudo-code for money in circulation under the assumptions of \ac{lifo} and \ac{fifo} can be checked out in our open-source repository \url{https://github.com/wiberlin/ccurr_velocity}.
} %
Money in circulation can be estimated by looping trough all inputs \(\Inp_{t}\) of transaction \(t\). %
All inputs are searched for such that are referencing to either (1) outputs of coinbase transactions or to (2) outputs generated in transactions generated before the first timestamp of time window \(\wndw\) (compare Section \ref{sec:orig_approach}). %
For inputs of case (1) values \(\val(i)\) are aggregated to form \(\MCirc\). %
For case (2) values are only added, if they represent mining rewards instead of representing transaction fees (compare Section \ref{sec:improve_fees}). %
Looping over all inputs of transaction \(t\), the above summations form an estimate on how much money has been put into circulation. % 

This core-functionality is referenced as function throughout the paper as function \(GetMCirc\bigl(t,\,\wndw,\bigr)\). %
Let's first turn to the computation of \(\MSetCircLA[d]\) and \(\MSetCirc_{1}[d]\) respectively. %
Obviously, our implementation will just apply \(GetMCirc\bigl(t,\,\wndw,\bigr)\) to aggregate the money supply put into circulation by all transactions \(\TxD\) of day \(d\) that has been added when shifting the window in the inductive process. %
The computation of adjustment value \(\MSetCircLA[d]\) is slightly more complex. %
As given in line 14 of Algorithm \ref{algo:code_aggr}, we apply a function \(AdjustMCirc\bigl(t, d,\,\wndwLength\bigr)\) to all transactions in day \(d\). %
The inner workings of \(AdjustMCirc\bigl(t, d,\,\wndwLength\bigr)\) are illustrated in Algorithm \ref{algo:code_outs_spent_within}: %
Note, that in contrast to \(GetMCirc\bigl(t,\,\wndw,\bigr)\) where \(\wndw\) can be seen as look-back window, function \(AdjustMCirc\bigl(t, d,\,\wndwLength\bigr)\) does look ahead in time. %

To dertermine the corrective value based on transaction outputs from transactions during day \(\perd\) that can no longer be seen as ``respent-coins'' for window \(\wndw\), the look-ahead window \(\wndw^{\mathtt{ahead}}\) is created. %
It is formed using the bounds of the iteration period \(\perd\) and window length \(\wndwLength\). %

To aggregate the value of the transaction's outputs that have been spent by during window \(\wndw^{\mathtt{ahead}}\), Algorithm \ref{algo:code_aggr} loops through all outputs \(\Out_{t}\) of transaction \(t\). % 
For every output the \(\mathtt{date}(\spendingTx(o)\) establishes the date of the transaction spending the output. %
If this date is part of window \(\wndw\), the output's values are aggregated forming \(\MCircAdj\). %
For the output's ``spending-transacting'' we thus want to aggregate the values of outputs that represent money put into circulation with respect to the new window \(\wndw + 1\). %


% \textbf{[TODO: Change the denomination of the ``non-aggregated'' measures. They are confusion. This can be noticed here.]}
% For now, we will simply treat the above three structures as black boxes and focus on the iterative framework which starts at line 17 of Algorithm \ref{algo:code_aggr}.%
% \footnote{The calculations for the three helper-structure are summarized in the following paragraphs.} %

Inductive steps are taken for \(\perd \geq \wndw \).%
\footnote{
For days \(\perd < \wndw \), money put into circulation for a window \(\wndw\) by transactions of day \(\perd\) is simply the output-sum of coinbase transactions \(\MSetCbs[\perd]\). %
We use this intuition to initialize the algorithm.} %
First of all, money in circulation \(\MSetCircAggr[\perd]\) over window \(w\) is set to its last calculated value. %
This value is now the base for adjustments. %
Using the pre-computed values, we can simply follow the intuition laid out in \ref{sec:novel_impl_intuition}: %
We add \(\MSetCircLB[\perd]\), and thus money brought into circulation on day \(\iterhead\) to the still outdated \(\MSetCircAggr[\perd]\). %
After that, we adapt \(\MSetCircAggr[\perd]\) further by subtracting money in circulation for the day eliminated from the \(\wndw - 1\) and thus \(\MSetCirc_{1}[\itertail]\). %
Without further adjustment, however, we would ignore that by shifting the window boundaries certain transaction outputs cannot be seen any longer as ``respent-coins'' as the spent output no longer lies ``inside'' the respectiv time window. %
We thus add \( \MSetCircLA[\itertail] \) which, roughly spoken, aggregates money brought into circulation by transactions spending outputs of transactions during day \(d\) if the new window boundaries are applied. %



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%% If confusion arises between "days forming iteration steps" and "days of measurement" 
% Assume that money in circulation with a look-back time window of length \(\wndwLength\) is to be estimated for day \(\perd\). %
% The helper-structure estimates how much money is been brought into active circulation during the period \([\iterp_{\Start},\iterp_{\End}]\): Before the events at day \(\iterp\), the respective money supply has remained untouched for \(\wndwLength\) days. With its transaction at day \(\iterp\), however, it can now be seen as circulating within period  \([\wndw_\Start\) to \(\wndw_\End]\). %
% While the helper-structure is estimating the value of monetary units which are ``activated'' by transactions of day \( \iterp \), it does neglect outputs which turn into ``already spent'' outputs in prior days within window \(\wndw\). %
% For example, in figure \ref{fig:mcirc_concept}, if we estimated the money supply for the period of iteration step \(\iterp\) we would count only money in circulation of 3 missing that transaction TX-C ``outside'' of period \(i\) activated a money supply of 2 with INP-1. %
% As a consequence it only coincides with the original estimator for the special case of \(\iterp % \wndw\). %

% While the original estimator requires the information of each transaction in time-window \(\wndw\), the helper-construct looks only at the transactions of iteration-step \(\iterp\) and checks their inputs age against \(\wndw_\Start\). % 

% The above helper-construct can be seen as the centerpiece to realize the inductive framework. %
% Algorithm \ref{algo:code_mcirc} offers a detailed summary. %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{figure}[ht!]%
% 	\centering
% 	\ifdefined\varInputFigs%
% 	\input{ts_figs/aggr}
% 	\else%
% 	\fi%
% 	\caption{%
% 		Overview of inductive computation of $\MCirc$. %
% 	}%
% 	\label{fig:aggr}%
% \end{figure}%

\begin{center}
%    \ifdefined\varInputFigs%
    \includegraphics[width=1\linewidth]{fig/iterations_general}%
%    \else%
%    \fi%
  \captionof{figure}{General iteration procedure.}
  \label{fig:aggr}
\end{center}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main.tex"
%%% End:

