%
% line numbering
%
\renewcommand{\LinesNumbered}{%
	\setboolean{algocf@linesnumbered}{true}%
	\renewcommand{\algocf@linesnumbered}{\everypar={\nl}}}%

\let\oldnl\nl% Store \nl in \oldnl
\newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line

\ifdefined\varInputAlgos%
\renewcommand{\arraystretch}{1.90}%
%\todo{Do we mean non-recycling or not circulating?}%
\begin{algorithm*}[!h]%
	\DontPrintSemicolon
  \caption{Measurement of $\protect\MCirc$ for given $\typett$ (\acs*{wbaType}, \acs*{fifo}, \acs*{lifo}) within period $\perd$, window $\wndw$.%
  }\label{algo:code_mcirc_mc}%
%
	\KwData{$\wndw_\Start$                                                          \tcc*{Begin of look-back window $w$}}%
	\KwData{$ \TxP$                                                                 \tcc*{Set of transactions in period $\perd$}}%
	\KwData{$ \Out^{\selfchurn}$                                                    \tcc*{Set of self-churning outputs}}%
	\KwData{$ \Out^{\cbs}$                                                          \tcc*{Set of maps of coinbase outputs per blockheight, that represent transaction fees}}%
%
	$\MCirc  \gets {0}$                                                             \tcc*{Money supply to be estimated in period $\perd$ with window $\wndw$}%
%
	\ForEach {$ t \in \TxP $}%
	{%
		$\MCirc(t) \gets {0}$                                                       \tcc*{Set summand of $\MCirc(t)$ for every transaction $t$}%
		$\valO^\mathtt{break}(t) \gets {0}$                                         \tcc*{Set break condition helper for every transaction $t$}%
		$\valO^\sendToOthers(t)  \gets{\sum_{o\in{}\Out_{t}} \val(o)}$              \tcc*{Initialize amount of money sent to third parties with sum of outputs}%
		\lIf(\tcc*[f]{Skip current transaction and go to the next}){$\isCoinbase(t)\ \orbf\ \sum_{i\in{}\Inp_{t}} \val(i)\,=\,0$}{continue}%
		\eIf(\tcc*[f]{\ac*{wba}: Regarding all outgoing coins ensures all inputs are regarded}%
		){$\typett\,=\,\mathrm{\acs*{wbaType}}$}{%
			$\valO^\sendToOthers(t)  \gets{\valO^\sendToOthers(t) + \sum_{f\in{}\Fee_{t}} \val(f)}$%
			%
		}(\tcc*[f]{\ac*{mca}: Discounting selfchurning outputs}%
		){% 
			$\Out'_{t} \gets{\Out_{t}\cap\Out^{\selfchurn}}$                        \tcc*{Determine the set of selfchurning outputs of $t$}%
			$\valO^\sendToOthers(t)  \gets{\valO^\sendToOthers(t) - \sum_{o\in{}\Out'_{t}} \val(o) }$%
		}%
		\lIf(\tcc*[f]{Skip current transaction and go to the next}){$\valO^\sendToOthers(t) = 0$}{continue}%
		$\InpT(\typett) \gets{sort(\InpT,\ \typett)}$ \tcc*{sort ascending (\acs*{fifo})/descending (\acs*{lifo}) by generation time of inputs/ skip (\acs*{wbaType})}%
	    \ForEach {$i \in \InpT(\typett)$\label{algo:code_mcirc_mc_for}%
    	}{%
    		$\valIAdd \gets {0}$                                                   \tcc*{}%
	    	$\valO^\mathtt{break} \gets{\valO^\mathtt{break} + \valI(i)}$          \tcc*{Update foreach-loop break helper}%
	    	$\inpSpentCase \gets {GetInputSpentCase(i,\,\wndw_\Start)}$            \tcc*{Get value representing spent case of input $i$}%
	    	\lIf(\tcc*[f]{Input $i$ was generated within $\wndw$ by a normal transaction}){%
	    		$\inpSpentCase = 0$
	    	}{continue}% 
			\If(\tcc*[f]{Input $i$ was generated within $\wndw$ by a coinbase transaction}){%
				$\inpSpentCase = 2$
			}{%        
				$\Out^{\cbs}_{i} \gets{\Out^{\cbs}[\bhSpentTx(i)]}$                \tcc*{Get map of outputs of the coinbase tx that is referenced by input $i$}%
				$\keyInp \gets {"\addr(i)\_\val(i)"}$                              \tcc*{dictionary/map key for $\Out^{\cbs}_{i}$}%
				\If(\tcc*[f]{Check wheather $i$ represents fees}%
				){$\keyInp \in \Out^{\cbs}_{i}$
				}{%				
					$\minedRemIndex \gets {\Out^{\cbs}_{i}[\mathtt{"minedRemIndex"}]}$ \tcc*{Get index of the first output representing mined coins}%
					$\cbsOutIndex \gets {\Out^{\cbs}_{i}[\keyInp][0]}$                 \tcc*{Get index of the output referenced by $i$}%
					\lIf(\tcc*[f]{Input $i$ spent an output representing fees}%
					){$ \cbsOutIndex < \minedRemIndex$
					}{continue}% 
					\If(\tcc*[f]{Input $i$ (partly) represents mined coins}%
					){$ \cbsOutIndex = \minedRemIndex$
					}{%
						$\valIAdd \gets {\Out^{\cbs}_{i}[\mathtt{"minedRem"}]}$        \tcc*{Add (partly) mined coins referenced by $i$}%
					}%
				}%
			}%
			\If(\tcc*[f]{Input $i$ was generated before $\wndw_\Start$ regardless of the transaction type}){%
				$\inpSpentCase \in \{1,3\}$
			}{%        
				$\valIAdd \gets{\val(i)}$                                          \tcc*{Add the full value of $i$}%
			}% 
			$ \MCirc(t) \gets{\MCirc(t) + \valIAdd} $                              \tcc*{Update money supply}%
		  	\If{%
		  		$\valO^{\mathtt{break}}(t) > \valO^\sendToOthers(t)$%
		  	}{%
		  		\If(\tcc*[f]{Use $\valO^\sendToOthers(t)$ as upper cap for  $\MCirc(t)$}){%
		  			$\MCirc(t) > \valO^\sendToOthers(t)$%
		  		}{%
		  			$\MCirc(t) \gets{ \valO^\sendToOthers(t) }$%
		  		}{%
		  			break                                                          \tcc*{Break foreach-loop on line \ref{algo:code_mcirc_mc_for} and proceed with line \ref{algo:code_mcirc_mc_break}}%
		  		}% 
		  	}% 
		}%
	   	$ \MCirc \gets{\MCirc + \MCirc(t)} $\label{algo:code_mcirc_mc_break}%
	}%
	return $\MCirc$                                                                \tcc*{Result: Return estimated money in circulation in period $\perd$ with window $\wndw$}%
\end{algorithm*}%
\else%
\fi%
